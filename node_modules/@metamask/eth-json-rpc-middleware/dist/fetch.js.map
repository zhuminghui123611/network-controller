{"version":3,"file":"fetch.js","sourceRoot":"","sources":["../src/fetch.ts"],"names":[],"mappings":";;;AACA,+DAAkE;AAElE,qDAAiD;AAIjD,6CAA0C;AAE1C,MAAM,gBAAgB,GAAa;IACjC,gCAAgC;IAChC,iBAAiB;IACjB,WAAW;IACX,sCAAsC;IACtC,8BAA8B;IAC9B,+BAA+B;IAC/B,mDAAmD;IACnD,iBAAiB;CAClB,CAAC;AAsEF,SAAgB,qBAAqB,CACnC,IAYK;IAEL,IAAI,YAAY,IAAI,IAAI,EAAE;QACxB,OAAO,mCAAmC,CAAC,IAAI,CAAC,CAAC;KAClD;IACD,OAAO,sCAAsC,CAAC,IAAI,CAAC,CAAC;AACtD,CAAC;AAnBD,sDAmBC;AAED;;;;;;;;;;;GAWG;AACH,SAAS,mCAAmC,CAAC,EAC3C,UAAU,EACV,OAAO,GAAG,EAAE,GAMb;IACC,OAAO,IAAA,uCAAqB,EAC1B,KAAK,EAAE,GAA4C,EAAE,GAAG,EAAE,EAAE;QAC1D,MAAM,OAAO,GACX,qBAAqB,IAAI,OAAO;YAChC,OAAO,CAAC,mBAAmB,KAAK,SAAS;YACzC,GAAG,CAAC,MAAM,KAAK,SAAS;YACtB,CAAC,CAAC,EAAE,CAAC,OAAO,CAAC,mBAAmB,CAAC,EAAE,GAAG,CAAC,MAAM,EAAE;YAC/C,CAAC,CAAC,EAAE,CAAC;QAET,MAAM,eAAe,GAAG,MAAM,UAAU,CAAC,OAAO,CAC9C;YACE,EAAE,EAAE,GAAG,CAAC,EAAE;YACV,OAAO,EAAE,GAAG,CAAC,OAAO;YACpB,MAAM,EAAE,GAAG,CAAC,MAAM;YAClB,MAAM,EAAE,GAAG,CAAC,MAAM;SACnB,EACD;YACE,OAAO;SACR,CACF,CAAC;QAEF,0EAA0E;QAC1E,4CAA4C;QAC5C,sEAAsE;QACtE,uEAAuE;QACvE,IAAI,OAAO,IAAI,eAAe,EAAE;YAC9B,MAAM,sBAAS,CAAC,QAAQ,CAAC;gBACvB,IAAI,EAAE,eAAe,CAAC,KAAK;aAC5B,CAAC,CAAC;SACJ;QAED,6DAA6D;QAC7D,2CAA2C;QAC3C,GAAG,CAAC,MAAM,GAAG,eAAe,CAAC,MAAM,CAAC;IACtC,CAAC,CACF,CAAC;AACJ,CAAC;AAED;;;;;;;;;;;;GAYG;AACH,SAAS,sCAAsC,CAAC,EAC9C,IAAI,EAAE,SAAS,EACf,KAAK,EAAE,UAAU,EACjB,MAAM,EACN,mBAAmB,GAMpB;IACC,OAAO,IAAA,uCAAqB,EAAC,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,KAAK,EAAE,EAAE;QACrD,MAAM,EAAE,QAAQ,EAAE,WAAW,EAAE,GAAG,wBAAwB,CAAC;YACzD,IAAI,EAAE,SAAS;YACf,GAAG;YACH,MAAM;YACN,mBAAmB;SACpB,CAAC,CAAC;QAEH,iCAAiC;QACjC,MAAM,WAAW,GAAG,CAAC,CAAC;QACtB,MAAM,aAAa,GAAG,IAAI,CAAC;QAC3B,KAAK,IAAI,OAAO,GAAG,CAAC,EAAE,OAAO,GAAG,WAAW,EAAE,OAAO,EAAE,EAAE;YACtD,IAAI;gBACF,MAAM,QAAQ,GAAG,MAAM,UAAU,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;gBACzD,yBAAyB;gBACzB,kBAAkB,CAAC,QAAQ,CAAC,CAAC;gBAC7B,sBAAsB;gBACtB,MAAM,OAAO,GAAW,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAC;gBAC9C,IAAI,SAAgC,CAAC;gBACrC,IAAI;oBACF,SAAS,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;iBACjC;gBAAC,OAAO,CAAC,EAAE;oBACV,MAAM,IAAI,KAAK,CACb,qDAAqD,OAAO,GAAG,CAChE,CAAC;iBACH;gBACD,MAAM,MAAM,GAAU,aAAa,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;gBACzD,iCAAiC;gBACjC,GAAG,CAAC,MAAM,GAAG,MAAM,CAAC;gBACpB,OAAO;aACR;YAAC,OAAO,GAAQ,EAAE;gBACjB,MAAM,MAAM,GAAW,GAAG,CAAC,QAAQ,EAAE,CAAC;gBACtC,MAAM,WAAW,GAAY,gBAAgB,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,EAAE,CAC5D,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,CACxB,CAAC;gBACF,kCAAkC;gBAClC,IAAI,CAAC,WAAW,EAAE;oBAChB,MAAM,GAAG,CAAC;iBACX;aACF;YACD,wBAAwB;YACxB,MAAM,IAAA,iBAAO,EAAC,aAAa,CAAC,CAAC;SAC9B;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AAED,SAAS,kBAAkB,CAAC,QAAkB;IAC5C,mBAAmB;IACnB,QAAQ,QAAQ,CAAC,MAAM,EAAE;QACvB,KAAK,GAAG;YACN,MAAM,sBAAS,CAAC,cAAc,EAAE,CAAC;QAEnC,KAAK,GAAG;YACN,MAAM,oBAAoB,EAAE,CAAC;QAE/B,KAAK,GAAG,CAAC;QACT,KAAK,GAAG;YACN,MAAM,kBAAkB,EAAE,CAAC;QAE7B;YACE,MAAM;KACT;AACH,CAAC;AAED,SAAS,aAAa,CAAC,QAAkB,EAAE,IAA2B;IACpE,uBAAuB;IACvB,IAAI,QAAQ,CAAC,MAAM,KAAK,GAAG,EAAE;QAC3B,MAAM,sBAAS,CAAC,QAAQ,CAAC;YACvB,OAAO,EAAE,yBAAyB,QAAQ,CAAC,MAAM,GAAG;YACpD,IAAI,EAAE,IAAI;SACX,CAAC,CAAC;KACJ;IAED,sBAAsB;IACtB,IAAI,IAAI,CAAC,KAAK,EAAE;QACd,MAAM,sBAAS,CAAC,QAAQ,CAAC;YACvB,IAAI,EAAE,IAAI,CAAC,KAAK;SACjB,CAAC,CAAC;KACJ;IACD,2BAA2B;IAC3B,OAAO,IAAI,CAAC,MAAM,CAAC;AACrB,CAAC;AAED;;;;;;;;;;;;;GAaG;AACH,SAAgB,wBAAwB,CAAC;AACvC,wDAAwD;AACxD,IAAI,EACJ,GAAG,EACH,MAAM,EACN,mBAAmB,GAMpB;IACC,MAAM,SAAS,GAAQ,IAAI,GAAG,CAAC,MAAM,CAAC,CAAC;IACvC,MAAM,QAAQ,GAAW,sBAAsB,CAAC,SAAS,CAAC,CAAC;IAE3D,kBAAkB;IAClB,0CAA0C;IAC1C,MAAM,OAAO,GAAmB;QAC9B,EAAE,EAAE,GAAG,CAAC,EAAE;QACV,OAAO,EAAE,GAAG,CAAC,OAAO;QACpB,MAAM,EAAE,GAAG,CAAC,MAAM;QAClB,MAAM,EAAE,GAAG,CAAC,MAAM;KACnB,CAAC;IAEF,0CAA0C;IAC1C,MAAM,YAAY,GAAuB,GAAG,CAAC,MAAM,CAAC;IAEpD,yBAAyB;IACzB,MAAM,iBAAiB,GAAW,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;IAE1D,yBAAyB;IACzB,MAAM,WAAW,GAAY;QAC3B,MAAM,EAAE,MAAM;QACd,OAAO,EAAE;YACP,MAAM,EAAE,kBAAkB;YAC1B,cAAc,EAAE,kBAAkB;SACnC;QACD,IAAI,EAAE,iBAAiB;KACxB,CAAC;IAEF,4DAA4D;IAC5D,IAAI,SAAS,CAAC,QAAQ,IAAI,SAAS,CAAC,QAAQ,EAAE;QAC5C,MAAM,UAAU,GAAG,GAAG,SAAS,CAAC,QAAQ,IAAI,SAAS,CAAC,QAAQ,EAAE,CAAC;QACjE,MAAM,WAAW,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC;QACrC,WAAW,CAAC,OAAO,CAAC,aAAa,GAAG,SAAS,WAAW,EAAE,CAAC;KAC5D;IAED,yCAAyC;IACzC,IAAI,mBAAmB,IAAI,YAAY,EAAE;QACvC,WAAW,CAAC,OAAO,CAAC,mBAAmB,CAAC,GAAG,YAAY,CAAC;KACzD;IAED,OAAO,EAAE,QAAQ,EAAE,WAAW,EAAE,CAAC;AACnC,CAAC;AArDD,4DAqDC;AAED,SAAS,sBAAsB,CAAC,SAAc;IAC5C,IAAI,MAAM,GAAG,EAAE,CAAC;IAChB,MAAM,IAAI,SAAS,CAAC,QAAQ,CAAC;IAC7B,MAAM,IAAI,KAAK,SAAS,CAAC,QAAQ,EAAE,CAAC;IACpC,IAAI,SAAS,CAAC,IAAI,EAAE;QAClB,MAAM,IAAI,IAAI,SAAS,CAAC,IAAI,EAAE,CAAC;KAChC;IACD,MAAM,IAAI,GAAG,SAAS,CAAC,QAAQ,EAAE,CAAC;IAClC,MAAM,IAAI,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC;IAChC,OAAO,MAAM,CAAC;AAChB,CAAC;AAED,SAAS,oBAAoB;IAC3B,OAAO,sBAAS,CAAC,QAAQ,CAAC,EAAE,OAAO,EAAE,gCAAgC,EAAE,CAAC,CAAC;AAC3E,CAAC;AAED,SAAS,kBAAkB;IACzB,IAAI,GAAG,GAAG,yDAAyD,CAAC;IACpE,GAAG,IAAI,iEAAiE,CAAC;IACzE,OAAO,sBAAS,CAAC,QAAQ,CAAC,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC,CAAC;AAC9C,CAAC","sourcesContent":["import type { JsonRpcMiddleware } from '@metamask/json-rpc-engine';\nimport { createAsyncMiddleware } from '@metamask/json-rpc-engine';\nimport type { JsonRpcError, DataWithOptionalCause } from '@metamask/rpc-errors';\nimport { rpcErrors } from '@metamask/rpc-errors';\nimport type { Json, JsonRpcParams, JsonRpcRequest } from '@metamask/utils';\n\nimport type { AbstractRpcService, Block } from './types';\nimport { timeout } from './utils/timeout';\n\nconst RETRIABLE_ERRORS: string[] = [\n  // ignore server overload errors\n  'Gateway timeout',\n  'ETIMEDOUT',\n  // ignore server sent html error pages\n  // or truncated json responses\n  'failed to parse response body',\n  // ignore errors where http req failed to establish\n  'Failed to fetch',\n];\n\n/**\n * @deprecated Please use {@link JsonRpcRequestWithOrigin} instead.\n */\nexport interface PayloadWithOrigin extends JsonRpcRequest {\n  origin?: string;\n}\n\n/**\n * Like a JSON-RPC request, but includes an optional `origin` property.\n * This will be included in the request as a header if specified.\n */\ntype JsonRpcRequestWithOrigin<Params extends JsonRpcParams> =\n  JsonRpcRequest<Params> & {\n    origin?: string;\n  };\n\ninterface Request {\n  method: string;\n  headers: Record<string, string>;\n  body: string;\n}\ninterface FetchConfig {\n  fetchUrl: string;\n  fetchParams: Request;\n}\n\n/**\n * Creates middleware for sending a JSON-RPC request through the given RPC\n * service.\n *\n * @param args - The arguments to this function.\n * @param args.rpcService - The RPC service to use.\n * @param args.options - Options.\n * @param args.options.originHttpHeaderKey - If provided, the origin field for\n * each JSON-RPC request will be attached to each outgoing fetch request under\n * this header.\n * @returns The fetch middleware.\n */\nexport function createFetchMiddleware(args: {\n  rpcService: AbstractRpcService;\n  options?: {\n    originHttpHeaderKey?: string;\n  };\n}): JsonRpcMiddleware<JsonRpcParams, Json>;\n\n/**\n * Creates middleware for sending a JSON-RPC request to the given RPC URL.\n *\n * @deprecated This overload is deprecated â€” please pass an `RpcService`\n * instance from `@metamask/network-controller` instead.\n * @param args - The arguments to this function.\n * @param args.btoa - Generates a base64-encoded string from a binary string.\n * @param args.fetch - The `fetch` function; expected to be equivalent to\n * `window.fetch`.\n * @param args.rpcUrl - The URL to send the request to.\n * @param args.originHttpHeaderKey - If provided, the origin field for each\n * JSON-RPC request will be attached to each outgoing fetch request under this\n * header.\n * @returns The fetch middleware.\n */\n// eslint-disable-next-line @typescript-eslint/unified-signatures\nexport function createFetchMiddleware(args: {\n  btoa: (stringToEncode: string) => string;\n  fetch: typeof fetch;\n  rpcUrl: string;\n  originHttpHeaderKey?: string;\n}): JsonRpcMiddleware<JsonRpcParams, Json>;\n\nexport function createFetchMiddleware(\n  args:\n    | {\n        rpcService: AbstractRpcService;\n        options?: {\n          originHttpHeaderKey?: string;\n        };\n      }\n    | {\n        btoa: (stringToEncode: string) => string;\n        fetch: typeof fetch;\n        rpcUrl: string;\n        originHttpHeaderKey?: string;\n      },\n): JsonRpcMiddleware<JsonRpcParams, Json> {\n  if ('rpcService' in args) {\n    return createFetchMiddlewareWithRpcService(args);\n  }\n  return createFetchMiddlewareWithoutRpcService(args);\n}\n\n/**\n * Creates middleware for sending a JSON-RPC request through the given RPC\n * service.\n *\n * @param args - The arguments to this function.\n * @param args.rpcService - The RPC service to use.\n * @param args.options - Options.\n * @param args.options.originHttpHeaderKey - If provided, the origin field for\n * each JSON-RPC request will be attached to each outgoing fetch request under\n * this header.\n * @returns The fetch middleware.\n */\nfunction createFetchMiddlewareWithRpcService({\n  rpcService,\n  options = {},\n}: {\n  rpcService: AbstractRpcService;\n  options?: {\n    originHttpHeaderKey?: string;\n  };\n}): JsonRpcMiddleware<JsonRpcParams, Json> {\n  return createAsyncMiddleware(\n    async (req: JsonRpcRequestWithOrigin<JsonRpcParams>, res) => {\n      const headers =\n        'originHttpHeaderKey' in options &&\n        options.originHttpHeaderKey !== undefined &&\n        req.origin !== undefined\n          ? { [options.originHttpHeaderKey]: req.origin }\n          : {};\n\n      const jsonRpcResponse = await rpcService.request(\n        {\n          id: req.id,\n          jsonrpc: req.jsonrpc,\n          method: req.method,\n          params: req.params,\n        },\n        {\n          headers,\n        },\n      );\n\n      // NOTE: We intentionally do not test to see if `jsonRpcResponse.error` is\n      // strictly a JSON-RPC error response as per\n      // <https://www.jsonrpc.org/specification#error_object> to account for\n      // Ganache returning error objects with extra properties such as `name`\n      if ('error' in jsonRpcResponse) {\n        throw rpcErrors.internal({\n          data: jsonRpcResponse.error,\n        });\n      }\n\n      // Discard the `id` and `jsonrpc` fields in the response body\n      // (the JSON-RPC engine will fill those in)\n      res.result = jsonRpcResponse.result;\n    },\n  );\n}\n\n/**\n * Creates middleware for sending a JSON-RPC request to the given RPC URL.\n *\n * @param args - The arguments to this function.\n * @param args.btoa - Generates a base64-encoded string from a binary string.\n * @param args.fetch - The `fetch` function; expected to be equivalent to\n * `window.fetch`.\n * @param args.rpcUrl - The URL to send the request to.\n * @param args.originHttpHeaderKey - If provider, the origin field for each\n * JSON-RPC request will be attached to each outgoing fetch request under this\n * header.\n * @returns The fetch middleware.\n */\nfunction createFetchMiddlewareWithoutRpcService({\n  btoa: givenBtoa,\n  fetch: givenFetch,\n  rpcUrl,\n  originHttpHeaderKey,\n}: {\n  btoa: (stringToEncode: string) => string;\n  fetch: typeof fetch;\n  rpcUrl: string;\n  originHttpHeaderKey?: string;\n}): JsonRpcMiddleware<JsonRpcParams, Json> {\n  return createAsyncMiddleware(async (req, res, _next) => {\n    const { fetchUrl, fetchParams } = createFetchConfigFromReq({\n      btoa: givenBtoa,\n      req,\n      rpcUrl,\n      originHttpHeaderKey,\n    });\n\n    // attempt request multiple times\n    const maxAttempts = 5;\n    const retryInterval = 1000;\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      try {\n        const fetchRes = await givenFetch(fetchUrl, fetchParams);\n        // check for http errrors\n        checkForHttpErrors(fetchRes);\n        // parse response body\n        const rawBody: string = await fetchRes.text();\n        let fetchBody: Record<string, Block>;\n        try {\n          fetchBody = JSON.parse(rawBody);\n        } catch (_) {\n          throw new Error(\n            `FetchMiddleware - failed to parse response body: \"${rawBody}\"`,\n          );\n        }\n        const result: Block = parseResponse(fetchRes, fetchBody);\n        // set result and exit retry loop\n        res.result = result;\n        return;\n      } catch (err: any) {\n        const errMsg: string = err.toString();\n        const isRetriable: boolean = RETRIABLE_ERRORS.some((phrase) =>\n          errMsg.includes(phrase),\n        );\n        // re-throw error if not retriable\n        if (!isRetriable) {\n          throw err;\n        }\n      }\n      // delay before retrying\n      await timeout(retryInterval);\n    }\n  });\n}\n\nfunction checkForHttpErrors(fetchRes: Response): void {\n  // check for errors\n  switch (fetchRes.status) {\n    case 405:\n      throw rpcErrors.methodNotFound();\n\n    case 418:\n      throw createRatelimitError();\n\n    case 503:\n    case 504:\n      throw createTimeoutError();\n\n    default:\n      break;\n  }\n}\n\nfunction parseResponse(fetchRes: Response, body: Record<string, Block>): Block {\n  // check for error code\n  if (fetchRes.status !== 200) {\n    throw rpcErrors.internal({\n      message: `Non-200 status code: '${fetchRes.status}'`,\n      data: body,\n    });\n  }\n\n  // check for rpc error\n  if (body.error) {\n    throw rpcErrors.internal({\n      data: body.error,\n    });\n  }\n  // return successful result\n  return body.result;\n}\n\n/**\n * Generate `fetch` configuration for sending the given request to an RPC API.\n *\n * @deprecated This function was created to support a now-deprecated signature\n * for {@link createFetchMiddleware}. It will be removed in a future major\n * version.\n * @param options - Options\n * @param options.btoa - Generates a base64-encoded string from a binary string.\n * @param options.rpcUrl - The URL to send the request to.\n * @param options.originHttpHeaderKey - If provider, the origin field for each JSON-RPC request\n * will be attached to each outgoing fetch request under this header.\n * @param options.req\n * @returns The fetch middleware.\n */\nexport function createFetchConfigFromReq({\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  btoa,\n  req,\n  rpcUrl,\n  originHttpHeaderKey,\n}: {\n  btoa: (stringToEncode: string) => string;\n  rpcUrl: string;\n  originHttpHeaderKey?: string;\n  req: PayloadWithOrigin;\n}): FetchConfig {\n  const parsedUrl: URL = new URL(rpcUrl);\n  const fetchUrl: string = normalizeUrlFromParsed(parsedUrl);\n\n  // prepare payload\n  // copy only canonical json rpc properties\n  const payload: JsonRpcRequest = {\n    id: req.id,\n    jsonrpc: req.jsonrpc,\n    method: req.method,\n    params: req.params,\n  };\n\n  // extract 'origin' parameter from request\n  const originDomain: string | undefined = req.origin;\n\n  // serialize request body\n  const serializedPayload: string = JSON.stringify(payload);\n\n  // configure fetch params\n  const fetchParams: Request = {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n    },\n    body: serializedPayload,\n  };\n\n  // encoded auth details as header (not allowed in fetch url)\n  if (parsedUrl.username && parsedUrl.password) {\n    const authString = `${parsedUrl.username}:${parsedUrl.password}`;\n    const encodedAuth = btoa(authString);\n    fetchParams.headers.Authorization = `Basic ${encodedAuth}`;\n  }\n\n  // optional: add request origin as header\n  if (originHttpHeaderKey && originDomain) {\n    fetchParams.headers[originHttpHeaderKey] = originDomain;\n  }\n\n  return { fetchUrl, fetchParams };\n}\n\nfunction normalizeUrlFromParsed(parsedUrl: URL): string {\n  let result = '';\n  result += parsedUrl.protocol;\n  result += `//${parsedUrl.hostname}`;\n  if (parsedUrl.port) {\n    result += `:${parsedUrl.port}`;\n  }\n  result += `${parsedUrl.pathname}`;\n  result += `${parsedUrl.search}`;\n  return result;\n}\n\nfunction createRatelimitError(): JsonRpcError<DataWithOptionalCause> {\n  return rpcErrors.internal({ message: `Request is being rate limited.` });\n}\n\nfunction createTimeoutError(): JsonRpcError<DataWithOptionalCause> {\n  let msg = `Gateway timeout. The request took too long to process. `;\n  msg += `This can happen when querying logs over too wide a block range.`;\n  return rpcErrors.internal({ message: msg });\n}\n"]}