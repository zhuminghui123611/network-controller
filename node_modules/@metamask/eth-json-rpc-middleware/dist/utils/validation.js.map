{"version":3,"file":"validation.js","sourceRoot":"","sources":["../../src/utils/validation.ts"],"names":[],"mappings":";;;AAAA,qDAAiE;AAEjE,uDAAiD;AAG1C,KAAK,UAAU,6BAA6B,CACjD,OAAY,EACZ,GAAmB,EACnB,EAAE,WAAW,EAA+D;IAE5E,IACE,OAAO,OAAO,KAAK,QAAQ;QAC3B,OAAO,CAAC,MAAM,GAAG,CAAC;QAClB,gBAAgB,CAAC,OAAO,CAAC,EACzB;QACA,iEAAiE;QACjE,+CAA+C;QAC/C,MAAM,QAAQ,GAAG,MAAM,WAAW,CAAC,GAAG,CAAC,CAAC;QAExC,MAAM,kBAAkB,GAAa,QAAQ,CAAC,GAAG,CAAC,CAAC,QAAQ,EAAE,EAAE,CAC7D,QAAQ,CAAC,WAAW,EAAE,CACvB,CAAC;QAEF,MAAM,iBAAiB,GAAG,OAAO,CAAC,WAAW,EAAS,CAAC;QAEvD,IAAI,kBAAkB,CAAC,QAAQ,CAAC,iBAAiB,CAAC,EAAE;YAClD,OAAO,iBAAiB,CAAC;SAC1B;QAED,MAAM,2BAAc,CAAC,YAAY,EAAE,CAAC;KACrC;IAED,MAAM,sBAAS,CAAC,aAAa,CAAC;QAC5B,OAAO,EAAE,uDAAuD;KACjE,CAAC,CAAC;AACL,CAAC;AA9BD,sEA8BC;AAED,SAAgB,cAAc,CAC5B,KAA2B,EAC3B,MAA0B;IAE1B,MAAM,CAAC,KAAK,CAAC,GAAG,IAAA,sBAAQ,EAAC,KAAK,EAAE,MAAM,CAAC,CAAC;IAExC,IAAI,KAAK,EAAE;QACT,MAAM,sBAAS,CAAC,aAAa,CAC3B,qBAAqB,CAAC,KAAK,EAAE,gBAAgB,CAAC,CAC/C,CAAC;KACH;AACH,CAAC;AAXD,wCAWC;AAED,SAAgB,gBAAgB,CAAC,GAAW;IAC1C,0BAA0B;IAC1B,OAAO,GAAG,CAAC,MAAM,KAAK,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;AACnC,CAAC;AAHD,4CAGC;AAED,SAAS,qBAAqB,CAAC,KAAkB,EAAE,OAAe;IAChE,OAAO,GAAG,OAAO,OAAO,KAAK;SAC1B,QAAQ,EAAE;SACV,GAAG,CACF,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,OAAO,EAAE,CACxE;SACA,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC;AAClB,CAAC","sourcesContent":["import { providerErrors, rpcErrors } from '@metamask/rpc-errors';\nimport type { Struct, StructError } from '@metamask/superstruct';\nimport { validate } from '@metamask/superstruct';\nimport type { Hex, JsonRpcRequest } from '@metamask/utils';\n\nexport async function validateAndNormalizeKeyholder(\n  address: Hex,\n  req: JsonRpcRequest,\n  { getAccounts }: { getAccounts: (req: JsonRpcRequest) => Promise<string[]> },\n): Promise<Hex> {\n  if (\n    typeof address === 'string' &&\n    address.length > 0 &&\n    resemblesAddress(address)\n  ) {\n    // Ensure that an \"unauthorized\" error is thrown if the requester\n    // does not have the `eth_accounts` permission.\n    const accounts = await getAccounts(req);\n\n    const normalizedAccounts: string[] = accounts.map((_address) =>\n      _address.toLowerCase(),\n    );\n\n    const normalizedAddress = address.toLowerCase() as Hex;\n\n    if (normalizedAccounts.includes(normalizedAddress)) {\n      return normalizedAddress;\n    }\n\n    throw providerErrors.unauthorized();\n  }\n\n  throw rpcErrors.invalidParams({\n    message: `Invalid parameters: must provide an Ethereum address.`,\n  });\n}\n\nexport function validateParams<ParamsType>(\n  value: unknown | ParamsType,\n  struct: Struct<ParamsType>,\n): asserts value is ParamsType {\n  const [error] = validate(value, struct);\n\n  if (error) {\n    throw rpcErrors.invalidParams(\n      formatValidationError(error, `Invalid params`),\n    );\n  }\n}\n\nexport function resemblesAddress(str: string): boolean {\n  // hex prefix 2 + 20 bytes\n  return str.length === 2 + 20 * 2;\n}\n\nfunction formatValidationError(error: StructError, message: string): string {\n  return `${message}\\n\\n${error\n    .failures()\n    .map(\n      (f) => `${f.path.join(' > ')}${f.path.length ? ' - ' : ''}${f.message}`,\n    )\n    .join('\\n')}`;\n}\n"]}