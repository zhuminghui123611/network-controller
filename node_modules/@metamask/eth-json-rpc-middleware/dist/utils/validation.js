"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resemblesAddress = exports.validateParams = exports.validateAndNormalizeKeyholder = void 0;
const rpc_errors_1 = require("@metamask/rpc-errors");
const superstruct_1 = require("@metamask/superstruct");
async function validateAndNormalizeKeyholder(address, req, { getAccounts }) {
    if (typeof address === 'string' &&
        address.length > 0 &&
        resemblesAddress(address)) {
        // Ensure that an "unauthorized" error is thrown if the requester
        // does not have the `eth_accounts` permission.
        const accounts = await getAccounts(req);
        const normalizedAccounts = accounts.map((_address) => _address.toLowerCase());
        const normalizedAddress = address.toLowerCase();
        if (normalizedAccounts.includes(normalizedAddress)) {
            return normalizedAddress;
        }
        throw rpc_errors_1.providerErrors.unauthorized();
    }
    throw rpc_errors_1.rpcErrors.invalidParams({
        message: `Invalid parameters: must provide an Ethereum address.`,
    });
}
exports.validateAndNormalizeKeyholder = validateAndNormalizeKeyholder;
function validateParams(value, struct) {
    const [error] = (0, superstruct_1.validate)(value, struct);
    if (error) {
        throw rpc_errors_1.rpcErrors.invalidParams(formatValidationError(error, `Invalid params`));
    }
}
exports.validateParams = validateParams;
function resemblesAddress(str) {
    // hex prefix 2 + 20 bytes
    return str.length === 2 + 20 * 2;
}
exports.resemblesAddress = resemblesAddress;
function formatValidationError(error, message) {
    return `${message}\n\n${error
        .failures()
        .map((f) => `${f.path.join(' > ')}${f.path.length ? ' - ' : ''}${f.message}`)
        .join('\n')}`;
}
//# sourceMappingURL=validation.js.map