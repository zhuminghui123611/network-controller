"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWalletMiddleware = void 0;
const sigUtil = __importStar(require("@metamask/eth-sig-util"));
const json_rpc_engine_1 = require("@metamask/json-rpc-engine");
const rpc_errors_1 = require("@metamask/rpc-errors");
const utils_1 = require("@metamask/utils");
const wallet_get_calls_status_1 = require("./methods/wallet-get-calls-status");
const wallet_get_capabilities_1 = require("./methods/wallet-get-capabilities");
const wallet_send_calls_1 = require("./methods/wallet-send-calls");
const common_1 = require("./utils/common");
const normalize_1 = require("./utils/normalize");
const validation_1 = require("./utils/validation");
function createWalletMiddleware({ getAccounts, getCallsStatus, getCapabilities, processDecryptMessage, processEncryptionPublicKey, processPersonalMessage, processTransaction, processSignTransaction, processTypedMessage, processTypedMessageV3, processTypedMessageV4, processSendCalls, }) {
    if (!getAccounts) {
        throw new Error('opts.getAccounts is required');
    }
    return (0, json_rpc_engine_1.createScaffoldMiddleware)({
        // account lookups
        eth_accounts: (0, json_rpc_engine_1.createAsyncMiddleware)(lookupAccounts),
        eth_coinbase: (0, json_rpc_engine_1.createAsyncMiddleware)(lookupDefaultAccount),
        // tx signatures
        eth_sendTransaction: (0, json_rpc_engine_1.createAsyncMiddleware)(sendTransaction),
        eth_signTransaction: (0, json_rpc_engine_1.createAsyncMiddleware)(signTransaction),
        // message signatures
        eth_signTypedData: (0, json_rpc_engine_1.createAsyncMiddleware)(signTypedData),
        eth_signTypedData_v3: (0, json_rpc_engine_1.createAsyncMiddleware)(signTypedDataV3),
        eth_signTypedData_v4: (0, json_rpc_engine_1.createAsyncMiddleware)(signTypedDataV4),
        personal_sign: (0, json_rpc_engine_1.createAsyncMiddleware)(personalSign),
        eth_getEncryptionPublicKey: (0, json_rpc_engine_1.createAsyncMiddleware)(encryptionPublicKey),
        eth_decrypt: (0, json_rpc_engine_1.createAsyncMiddleware)(decryptMessage),
        personal_ecRecover: (0, json_rpc_engine_1.createAsyncMiddleware)(personalRecover),
        // EIP-5792
        wallet_getCapabilities: (0, json_rpc_engine_1.createAsyncMiddleware)(async (params, req) => (0, wallet_get_capabilities_1.walletGetCapabilities)(params, req, { getAccounts, getCapabilities })),
        wallet_sendCalls: (0, json_rpc_engine_1.createAsyncMiddleware)(async (params, req) => (0, wallet_send_calls_1.walletSendCalls)(params, req, { getAccounts, processSendCalls })),
        wallet_getCallsStatus: (0, json_rpc_engine_1.createAsyncMiddleware)(async (params, req) => (0, wallet_get_calls_status_1.walletGetCallsStatus)(params, req, {
            getCallsStatus,
        })),
    });
    //
    // account lookups
    //
    async function lookupAccounts(req, res) {
        res.result = await getAccounts(req);
    }
    async function lookupDefaultAccount(req, res) {
        const accounts = await getAccounts(req);
        res.result = accounts[0] || null;
    }
    //
    // transaction signatures
    //
    async function sendTransaction(req, res) {
        if (!processTransaction) {
            throw rpc_errors_1.rpcErrors.methodNotSupported();
        }
        if (!req.params ||
            !Array.isArray(req.params) ||
            !(req.params.length >= 1)) {
            throw rpc_errors_1.rpcErrors.invalidInput();
        }
        const params = req.params[0];
        const txParams = Object.assign(Object.assign({}, params), { from: await validateAndNormalizeKeyholder((params === null || params === void 0 ? void 0 : params.from) || '', req) });
        res.result = await processTransaction(txParams, req);
    }
    async function signTransaction(req, res) {
        if (!processSignTransaction) {
            throw rpc_errors_1.rpcErrors.methodNotSupported();
        }
        if (!req.params ||
            !Array.isArray(req.params) ||
            !(req.params.length >= 1)) {
            throw rpc_errors_1.rpcErrors.invalidInput();
        }
        const params = req.params[0];
        const txParams = Object.assign(Object.assign({}, params), { from: await validateAndNormalizeKeyholder((params === null || params === void 0 ? void 0 : params.from) || '', req) });
        res.result = await processSignTransaction(txParams, req);
    }
    //
    // message signatures
    //
    async function signTypedData(req, res) {
        if (!processTypedMessage) {
            throw rpc_errors_1.rpcErrors.methodNotSupported();
        }
        if (!(req === null || req === void 0 ? void 0 : req.params) ||
            !Array.isArray(req.params) ||
            !(req.params.length >= 2)) {
            throw rpc_errors_1.rpcErrors.invalidInput();
        }
        const params = req.params;
        const message = params[0];
        const address = await validateAndNormalizeKeyholder(params[1], req);
        const version = 'V1';
        const extraParams = params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message, signatureMethod: 'eth_signTypedData', version });
        res.result = await processTypedMessage(msgParams, req, version);
    }
    async function signTypedDataV3(req, res) {
        if (!processTypedMessageV3) {
            throw rpc_errors_1.rpcErrors.methodNotSupported();
        }
        if (!(req === null || req === void 0 ? void 0 : req.params) ||
            !Array.isArray(req.params) ||
            !(req.params.length >= 2)) {
            throw rpc_errors_1.rpcErrors.invalidInput();
        }
        const params = req.params;
        const address = await validateAndNormalizeKeyholder(params[0], req);
        const message = (0, normalize_1.normalizeTypedMessage)(params[1]);
        validatePrimaryType(message);
        validateVerifyingContract(message);
        const version = 'V3';
        const msgParams = {
            data: message,
            from: address,
            version,
            signatureMethod: 'eth_signTypedData_v3',
        };
        res.result = await processTypedMessageV3(msgParams, req, version);
    }
    async function signTypedDataV4(req, res) {
        if (!processTypedMessageV4) {
            throw rpc_errors_1.rpcErrors.methodNotSupported();
        }
        if (!(req === null || req === void 0 ? void 0 : req.params) ||
            !Array.isArray(req.params) ||
            !(req.params.length >= 2)) {
            throw rpc_errors_1.rpcErrors.invalidInput();
        }
        const params = req.params;
        const address = await validateAndNormalizeKeyholder(params[0], req);
        const message = (0, normalize_1.normalizeTypedMessage)(params[1]);
        validatePrimaryType(message);
        validateVerifyingContract(message);
        const version = 'V4';
        const msgParams = {
            data: message,
            from: address,
            version,
            signatureMethod: 'eth_signTypedData_v4',
        };
        res.result = await processTypedMessageV4(msgParams, req, version);
    }
    async function personalSign(req, res) {
        if (!processPersonalMessage) {
            throw rpc_errors_1.rpcErrors.methodNotSupported();
        }
        if (!(req === null || req === void 0 ? void 0 : req.params) ||
            !Array.isArray(req.params) ||
            !(req.params.length >= 2)) {
            throw rpc_errors_1.rpcErrors.invalidInput();
        }
        const params = req.params;
        // process normally
        const firstParam = params[0];
        const secondParam = params[1];
        // non-standard "extraParams" to be appended to our "msgParams" obj
        const extraParams = params[2] || {};
        // We initially incorrectly ordered these parameters.
        // To gracefully respect users who adopted this API early,
        // we are currently gracefully recovering from the wrong param order
        // when it is clearly identifiable.
        //
        // That means when the first param is definitely an address,
        // and the second param is definitely not, but is hex.
        let address, message;
        if ((0, validation_1.resemblesAddress)(firstParam) && !(0, validation_1.resemblesAddress)(secondParam)) {
            let warning = `The eth_personalSign method requires params ordered `;
            warning += `[message, address]. This was previously handled incorrectly, `;
            warning += `and has been corrected automatically. `;
            warning += `Please switch this param order for smooth behavior in the future.`;
            res.warning = warning;
            address = firstParam;
            message = secondParam;
        }
        else {
            message = firstParam;
            address = secondParam;
        }
        address = await validateAndNormalizeKeyholder(address, req);
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message, signatureMethod: 'personal_sign' });
        // eslint-disable-next-line require-atomic-updates
        res.result = await processPersonalMessage(msgParams, req);
    }
    async function personalRecover(req, res) {
        if (!(req === null || req === void 0 ? void 0 : req.params) ||
            !Array.isArray(req.params) ||
            !(req.params.length >= 2)) {
            throw rpc_errors_1.rpcErrors.invalidInput();
        }
        const params = req.params;
        const message = params[0];
        const signature = params[1];
        const signerAddress = sigUtil.recoverPersonalSignature({
            data: message,
            signature,
        });
        res.result = signerAddress;
    }
    async function encryptionPublicKey(req, res) {
        if (!processEncryptionPublicKey) {
            throw rpc_errors_1.rpcErrors.methodNotSupported();
        }
        if (!(req === null || req === void 0 ? void 0 : req.params) ||
            !Array.isArray(req.params) ||
            !(req.params.length >= 1)) {
            throw rpc_errors_1.rpcErrors.invalidInput();
        }
        const params = req.params;
        const address = await validateAndNormalizeKeyholder(params[0], req);
        res.result = await processEncryptionPublicKey(address, req);
    }
    async function decryptMessage(req, res) {
        if (!processDecryptMessage) {
            throw rpc_errors_1.rpcErrors.methodNotSupported();
        }
        if (!(req === null || req === void 0 ? void 0 : req.params) ||
            !Array.isArray(req.params) ||
            !(req.params.length >= 1)) {
            throw rpc_errors_1.rpcErrors.invalidInput();
        }
        const params = req.params;
        const ciphertext = params[0];
        const address = await validateAndNormalizeKeyholder(params[1], req);
        const extraParams = params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: ciphertext });
        res.result = await processDecryptMessage(msgParams, req);
    }
    //
    // utility
    //
    /**
     * Validates the keyholder address, and returns a normalized (i.e. lowercase)
     * copy of it.
     *
     * @param address - The address to validate and normalize.
     * @param req - The request object.
     * @returns {string} - The normalized address, if valid. Otherwise, throws
     * an error
     */
    async function validateAndNormalizeKeyholder(address, req) {
        return (0, validation_1.validateAndNormalizeKeyholder)(address, req, { getAccounts });
    }
}
exports.createWalletMiddleware = createWalletMiddleware;
/**
 * Validates primary of typedSignMessage, to ensure that it's type definition is present in message.
 *
 * @param data - The data passed in typedSign request.
 */
function validatePrimaryType(data) {
    const { primaryType, types } = (0, normalize_1.parseTypedMessage)(data);
    if (!types) {
        throw rpc_errors_1.rpcErrors.invalidInput();
    }
    // Primary type can be an array.
    const baseType = (0, common_1.stripArrayTypeIfPresent)(primaryType);
    // Return if the base type is not defined in the types
    const baseTypeDefinitions = types[baseType];
    if (!baseTypeDefinitions) {
        throw rpc_errors_1.rpcErrors.invalidInput();
    }
}
/**
 * Validates verifyingContract of typedSignMessage.
 *
 * @param data - The data passed in typedSign request.
 * This function allows the verifyingContract to be either:
 * - A valid hex address
 * - The string "cosmos" (as it is hard-coded in some Cosmos ecosystem's EVM adapters)
 * - An empty string
 */
function validateVerifyingContract(data) {
    const { domain: { verifyingContract } = {} } = (0, normalize_1.parseTypedMessage)(data);
    // Explicit check for cosmos here has been added to address this issue
    // https://github.com/MetaMask/eth-json-rpc-middleware/issues/337
    if (verifyingContract &&
        verifyingContract !== 'cosmos' &&
        !(0, utils_1.isValidHexAddress)(verifyingContract)) {
        throw rpc_errors_1.rpcErrors.invalidInput();
    }
}
//# sourceMappingURL=wallet.js.map